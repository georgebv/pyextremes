{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyextremes","text":"<p> pyextremes </p> <p> Extreme Value Analysis (EVA) in Python </p> <p>             </p>  <p>pyextremes is a Python library aimed at performing univariate Extreme Value Analysis (EVA)</p>"},{"location":"#features","title":"Features","text":"<p>pyextremes provides tools necessary to perform a wide range of tasks required to perform univariate EVA, such as:</p> <ul> <li>extraction of extreme events from time series using methods such as Block Maxima (BM) or Peaks Over Threshold (POT)</li> <li>fitting continuous distributions, such as GEVD, GPD, or user-specified continous distributions to the extracted extreme events</li> <li>visualization of model inputs, results, and goodness-of-fit statistics</li> <li>estimation of extreme events of given probability or return period (e.g. 100-year event) and of corresponding confidence intervals</li> <li>tools assisting with model selection and tuning, such as selection of block size in BM and threshold in POT</li> </ul> <p>Framework provided by the pyextremes library is easy to use and requires minimum user input to get production-ready results. Its default parameters are configured in compliance with best industry standards and underlying models are heavily based in the Extreme Value theory. The largest source of inspiration for this library was the book <code>\"An Introduction to Statistical Modeling of Extreme Values\"</code> by Stuart Coles.</p> <p>In addition to the easy-to-use interface, the library provides interface to underlying tools which can be used to build custom models. All scipy continuous distributions are supported out-of-the-box. Custom distributions can be also provided by subclassing scipy.stats.rv_continuous. Any parameter of a distribution may be frozen to investigate degenerate models (e.g. <code>GEVD -&gt; Gumbel</code> or <code>GPD -&gt; Exponential</code>).</p> <p>Multiple ways of fitting the continuous distributions to the data are supported:</p> <ul> <li><code>MLE</code> (default model) - Maximum Likelihood Estimate, uses SciPy</li> <li><code>Emcee</code> - Markov Chain Monte Calro, see Emcee package by Dan Foreman-Mackey</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Get latest version from PyPI:</p> <pre><code>pip install pyextremes\n</code></pre> <p>Install with optional dependencies:</p> <pre><code>pip install pyextremes[full]\n</code></pre> <p>Get latest experimental build from GitHub:</p> <pre><code>pip install \"git+https://github.com/georgebv/pyextremes.git#egg=pyextremes\"\n</code></pre> <p>For Anaconda Python distributions:</p> <pre><code>conda install -c conda-forge pyextremes\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"Package Description     emcee fit models using the Markov Chain Monte Carlo method   matplotlib produce figures   numpy perform efficient operations with arrays   pandas <code>Series</code> and <code>DataFrame</code> objects for model intput and output   scipy statistical models and mathematic functions"},{"location":"#optional-dependencies","title":"Optional Dependencies","text":"<p>Optional dependencies can be installed using the <code>full</code> tag as shown above or manually:</p>    Package Description     tqdm progress bar for slow processes"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"quickstart/","title":"Quick Start","text":""},{"location":"quickstart/#read-data","title":"Read data","text":"<p>Every <code>pyextremes</code> model starts with a <code>pandas.Series</code> (see pandas documentation) object, which contains timeseries of the data you want to analyze. This example is based on water level data for \"The Battery\" station located in New York.</p> <p>Read data:</p> <pre><code>import pandas as pd\n\nseries = pd.read_csv(\n    \"battery_wl.csv\",\n    index_col=0,\n    parse_dates=True,\n).squeeze()\n</code></pre>  <p>Tip</p> <p>The <code>battery_wl.csv</code> file referenced above is used throughout many tutorials and examples for the <code>pyextremes</code> package. If you want to reproduce all steps shown here and get the same results, the file can be downloaded here.</p>"},{"location":"quickstart/#clean-up-data","title":"Clean up data","text":"<p>In order for the analysis results to be meaningful, data needs to be pre-processed by the user. This may include removal of data gaps, detrending, interpolation, removal of outliers, etc. Let's clean up the data:</p> Code <pre><code>series = (\n    series\n    .sort_index(ascending=True)\n    .astype(float)\n    .dropna()\n    .loc[pd.to_datetime(\"1925\"):]\n)\nseries = series - (series.index.array - pd.to_datetime(\"1992\")) / pd.to_timedelta(\"365.2425D\") * 2.87e-3\n</code></pre>  When printed <pre><code>print(series.head())\n</code></pre> <pre><code>Date-Time (GMT)\n1926-11-20 05:00:00   -0.411120\n1926-11-20 06:00:00   -0.777120\n1926-11-20 07:00:00   -1.051120\n1926-11-20 08:00:00   -1.051121\n1926-11-20 09:00:00   -0.808121\nName: Water Elevation [m NAVD88], dtype: float64\n</code></pre>    Note <p>See this tutorial for more information on why these specific operations were done.</p>"},{"location":"quickstart/#create-model","title":"Create model","text":"<p>The primary interface to the pyextremes library is provided via the <code>EVA</code> class. This class is responsible for all major tasks outlined above and is created using a simple command:</p> <pre><code>from pyextremes import EVA\n\nmodel = EVA(series)\n</code></pre>"},{"location":"quickstart/#extract-extreme-values","title":"Extract extreme values","text":"<p>The first step of extreme value analysis is extraction of extreme values from the timeseries. This is done by using the <code>get_extremes</code> method of the <code>EVA</code> class.</p> <p>In this example extremes will be extracted using the BM <code>method</code> and 1-year <code>block_size</code>, which give us annual maxima series.</p> Code <pre><code>model.get_extremes(method=\"BM\", block_size=\"365.2425D\")\n</code></pre>  When printed <pre><code>print(model.extremes.head())\n</code></pre> <pre><code>Date-Time (GMT)\n1927-02-20 16:00:00    1.670154\n1927-12-05 10:00:00    1.432893\n1929-04-16 19:00:00    1.409977\n1930-08-23 01:00:00    1.202101\n1931-03-08 17:00:00    1.529547\nName: Water Elevation [m NAVD88], dtype: float64\n</code></pre>"},{"location":"quickstart/#visualize-extreme-events","title":"Visualize extreme events","text":"<pre><code>model.plot_extremes()\n</code></pre>"},{"location":"quickstart/#fit-a-model","title":"Fit a model","text":"<p>The next step is selecting a model and fitting to the extracted extreme events. What this means practically is that we need to find model parameters (such as shape, location and scale for GEVD or GPD) that maximize or minimize some metric (likelihood) and give us the best fit possible. This is done by calling the <code>fit_model</code> method:</p> <pre><code>model.fit_model()\n</code></pre>  <p>Info</p> <p>By default, the <code>fit_model</code> method selects the best model applicable to extracted extremes using the Akaike Information Criterion (AIC).</p>"},{"location":"quickstart/#calculate-return-values","title":"Calculate return values","text":"<p>The final goal of most EVA's is estimation of return values. The simplest way to do this is by using the <code>get_summary</code> method:</p> <pre><code>summary = model.get_summary(\n    return_period=[1, 2, 5, 10, 25, 50, 100, 250, 500, 1000],\n    alpha=0.95,\n    n_samples=1000,\n)\n</code></pre>  <p>Note</p> <p>By default return period size is set to one year, which is defined as the mean year from the Gregorian calendar (365.2425 days). This means that a return period of 100 corresponds to a 100-year event.</p> <p>A different return period size can be specified using the <code>return_period_size</code> argument. A value of <code>30D</code> (30 days) would mean that a return period of 12 corresponds to approximately one year.</p>  <p>Print the results:</p> <pre><code>print(summary)\n</code></pre> <pre><code>               return value  lower ci  upper ci\nreturn period\n1.0                0.802610 -0.270608  1.024385\n2.0                1.409343  1.370929  1.452727\n5.0                1.622565  1.540408  1.710116\n10.0               1.803499  1.678816  1.955386\n25.0               2.090267  1.851597  2.417670\n50.0               2.354889  1.992022  2.906734\n100.0              2.671313  2.145480  3.568418\n250.0              3.188356  2.346609  4.856107\n500.0              3.671580  2.517831  6.232830\n1000.0             4.252220  2.702800  8.036243\n</code></pre>"},{"location":"quickstart/#investigate-model","title":"Investigate model","text":"<p>After model results are obtained, logical questions naturally arise - how good is the model, are the obtained results meaningful, and how confident can I be with the estimated return values. One way to do that is by visually inspecting the model:</p> <pre><code>model.plot_diagnostic(alpha=0.95)\n</code></pre>"},{"location":"quickstart/#recap","title":"Recap","text":"<p>Following this example you should be able to do the following:</p> <ul> <li>set up an <code>EVA</code> instance</li> <li>extract extreme events</li> <li>fit a model</li> <li>get results</li> </ul> <p>For more in-depth tutorials on features of pyextremes see the User Guide.</p>"},{"location":"api/api/","title":"API documentation","text":"<p>Extreme Value Analysis (EVA) class.</p> <p>This class brings together most of the tools available in the pyextremes package bundled together in a pipeline to perform univariate extreme value analysis.</p> <p>A typical workflow using the EVA class would consist of the following:     - extract extreme values (.get_extremes)     - fit a model (.fit_model)     - generate outputs (.get_summary)     - visualize the model (.plot_diagnostic, .plot_return_values)</p> <p>Multiple additional graphical and numerical methods are available within this class to analyze extracted extreme values, visualize them, assess goodness-of-fit of selected model, and to visualize its outputs.</p>"},{"location":"api/api/#pyextremes.eva.EVA.__init__","title":"<code>__init__(data)</code>","text":"<p>Initialize EVA model.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>pandas.Series</code>  <p>Time series to be analyzed. Index must be date-time and values must be numeric.</p>  required"},{"location":"api/api/#pyextremes.eva.EVA.fit_model","title":"<code>fit_model(model='MLE', distribution=None, distribution_kwargs=None, **kwargs)</code>","text":"<p>Fit a model to the extracted extreme values.</p> <p>Parameters:</p>    Name Type Description Default     <code>model</code>  <code>str, optional</code>  <p>Name of model. By default it is 'MLE'. Name of model. Supported models: MLE - Maximum Likelihood Estimate (MLE) model. Based on 'scipy' package (scipy.stats.rv_continuous.fit). Emcee - Markov Chain Monte Carlo (MCMC) model. Based on 'emcee' package by Daniel Foreman-Mackey.</p>  <code>'MLE'</code>    <code>distribution</code>  <code>str or scipy.stats.rv_continuous, optional</code>  <p>Distribution name compatible with scipy.stats or a subclass of scipy.stats.rv_continuous. See https://docs.scipy.org/doc/scipy/reference/stats.html By default the distribution is selected automatically as best between 'genextreme' and 'gumbel_r' for 'BM' extremes and 'genpareto' and 'expon' for 'POT' extremes. Best distribution is selected using the AIC metric.</p>  <code>None</code>    <code>distribution_kwargs</code>  <code>dict, optional</code>  <p>Special keyword arguments, passsed to the <code>.fit</code> method of the distribution. These keyword arguments represent parameters to be held fixed. Names of parameters to be fixed must have 'f' prefixes. Valid parameters: - shape(s): 'fc', e.g. fc=0 - location: 'floc', e.g. floc=0 - scale: 'fscale', e.g. fscale=1 See documentation of a specific scipy.stats distribution for names of available parameters. By default, location parameter for 'genpareto' and 'expon' distributions is fixed to threshold (POT) or to minimum extremes (BM) value. Set to empty dictionary (distribution_kwargs={}) to avoid this behaviour.</p>  <code>None</code>    <code>kwargs</code>   <p>Keyword arguments passed to a model .fit method. MLE model: MLE model takes no additional arguments. Emcee model: n_walkers : int, optional The number of walkers in the ensemble (default=100). n_samples : int, optional The number of steps to run (default=500). progress : bool or str, optional If True, a progress bar will be shown as the sampler progresses. If a string, will select a specific tqdm progress bar. Most notable is 'notebook', which shows a progress bar suitable for Jupyter notebooks. If False (default), no progress bar will be shown. This progress bar is a part of the <code>emcee</code> package.</p>  <code>{}</code>"},{"location":"api/api/#pyextremes.eva.EVA.from_extremes","title":"<code>from_extremes(extremes, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an EVA model using pre-defined <code>extremes</code>.</p> <p>A typical reason to use this method is when full timeseries is not available and only the extracted extremes (i.e. annual maxima) are known.</p> <p>Parameters:</p>    Name Type Description Default     <code>extremes</code>  <code>pd.Series</code>  <p>Time series of extreme values.</p>  required    <code>kwargs</code>   <p>See '.set_extremes' method documentation.</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>EVA</code>  <p>EVA model initialized with <code>extremes</code>.</p>"},{"location":"api/api/#pyextremes.eva.EVA.get_extremes","title":"<code>get_extremes(method, extremes_type='high', **kwargs)</code>","text":"<p>Get extreme events from time series.</p> <p>Extracts extreme values from the 'self.data' attribute. Stores extreme values in the 'self.extremes' attribute.</p> <p>Parameters:</p>    Name Type Description Default     <code>method</code>  <code>str</code>  <p>Extreme value extraction method. Supported values: BM - Block Maxima POT - Peaks Over Threshold</p>  required    <code>extremes_type</code>  <code>str, optional</code>  <p>high (default) - get extreme high values low - get extreme low values</p>  <code>'high'</code>    <code>kwargs</code>   <p>if method is BM: block_size : str or pandas.Timedelta, optional Block size (default='365.2425D'). See pandas.to_timedelta for more information. errors : str, optional raise (default) - raise an exception when encountering a block with no data ignore - ignore blocks with no data coerce - get extreme values for blocks with no data as mean of all other extreme events in the series with index being the middle point of corresponding interval min_last_block : float, optional Minimum data availability ratio (0 to 1) in the last block for it to be used to extract extreme value from. This is used to discard last block when it is too short. If None (default), last block is always used. if method is POT: threshold : float Threshold used to find exceedances. r : pandas.Timedelta or value convertible to timedelta, optional Duration of window used to decluster the exceedances. By default r='24H' (24 hours). See pandas.to_timedelta for more information.</p>  <code>{}</code>"},{"location":"api/api/#pyextremes.eva.EVA.get_return_value","title":"<code>get_return_value(return_period, return_period_size='365.2425D', alpha=None, **kwargs)</code>","text":"<p>Get return value and confidence interval for given return period(s).</p> <p>Parameters:</p>    Name Type Description Default     <code>return_period</code>  <code>array-like</code>  <p>Return period or 1D array of return periods. Given as a multiple of <code>return_period_size</code>.</p>  required    <code>return_period_size</code>  <code>str or pandas.Timedelta, optional</code>  <p>Size of return periods (default='365.2425D'). If set to '30D', then a return period of 12 would be roughly equivalent to a 1 year return period (360 days).</p>  <code>'365.2425D'</code>    <code>alpha</code>  <code>float, optional</code>  <p>Width of confidence interval (0, 1). If None (default), return None for upper and lower confidence interval bounds.</p>  <code>None</code>    <code>kwargs</code>   <p>Model-specific keyword arguments. If alpha is None, keyword arguments are ignored (error still raised for unrecognized arguments). MLE model: n_samples : int, optional Number of bootstrap samples used to estimate confidence interval bounds (default=100). Emcee model: burn_in : int Burn-in value (number of first steps to discard for each walker).</p>  <code>{}</code>     <p>Returns:</p>    Name Type Description     <code>return_value</code>  <code>array-like</code>  <p>Return values.</p>   <code>ci_lower</code>  <code>array-like</code>  <p>Lower confidence interval bounds.</p>   <code>ci_upper</code>  <code>array-like</code>  <p>Upper confidence interval bounds.</p>"},{"location":"api/api/#pyextremes.eva.EVA.get_summary","title":"<code>get_summary(return_period, return_period_size='365.2425D', alpha=None, **kwargs)</code>","text":"<p>Generate a pandas DataFrame with return values and confidence interval bounds.</p> <p>Parameters:</p>    Name Type Description Default     <code>return_period</code>  <code>array-like</code>  <p>Return period or 1D array of return periods. Given as a multiple of <code>return_period_size</code>.</p>  required    <code>return_period_size</code>  <code>str or pandas.Timedelta, optional</code>  <p>Size of return periods (default='365.2425D'). If set to '30D', then a return period of 12 would be roughly equivalent to a 1 year return period (360 days).</p>  <code>'365.2425D'</code>    <code>alpha</code>  <code>float, optional</code>  <p>Width of confidence interval (0, 1). If None (default), return None for upper and lower confidence interval bounds.</p>  <code>None</code>    <code>kwargs</code>   <p>Model-specific keyword arguments. If alpha is None, keyword arguments are ignored (error still raised for unrecognized arguments). MLE model: n_samples : int, optional Number of bootstrap samples used to estimate confidence interval bounds (default=100). Emcee model: burn_in : int Burn-in value (number of first steps to discard for each walker).</p>  <code>{}</code>     <p>Returns:</p>    Name Type Description     <code>summary</code>  <code>pandas.DataFrame</code>  <p>DataFrame with return values and confidence interval bounds.</p>"},{"location":"api/api/#pyextremes.eva.EVA.plot_corner","title":"<code>plot_corner(burn_in=0, labels=None, levels=None, figsize=(8, 8))</code>","text":"<p>Plot corner plot for MCMC sampler trace.</p> <p>Parameters:</p>    Name Type Description Default     <code>burn_in</code>  <code>int, optional</code>  <p>Burn-in value (number of first steps to discard for each walker). By default it is 0 (no values are discarded).</p>  <code>0</code>    <code>labels</code>  <code>array-like, optional</code>  <p>Sequence of strings with parameter names, used to label axes. If None (default), then axes are labeled sequentially.</p>  <code>None</code>    <code>levels</code>  <code>int, optional</code>  <p>Number of Gaussian KDE contours to plot. If None (default), then not shown.</p>  <code>None</code>    <code>figsize</code>  <code>tuple, optional</code>  <p>Figure size in inches. By default it is (8, 8).</p>  <code>(8, 8)</code>     <p>Returns:</p>    Name Type Description     <code>figure</code>  <code>matplotlib.figure.Figure</code>  <p>Figure object.</p>   <code>axes</code>  <code>list</code>  <p>2D list with Axes objects of size N by N, where N is <code>trace.shape[2]</code>. Empty slots are represented by None. Axes are ordered from left to right top to bottom.</p>"},{"location":"api/api/#pyextremes.eva.EVA.plot_diagnostic","title":"<code>plot_diagnostic(return_period=None, return_period_size='365.2425D', alpha=None, plotting_position='weibull', figsize=(8, 8), **kwargs)</code>","text":"<p>Plot a diagnostic plot.</p> <p>This plot shows four key plots characterizing the EVA model:     - top left : return values plot     - top right : probability density (PDF) plot     - bottom left : quantile (Q-Q) plot     - bottom right : probability (P-P) plot</p> <p>Parameters:</p>    Name Type Description Default     <code>return_period</code>  <code>array-like, optional</code>  <p>Return period or 1D array of return periods. Given as a multiple of <code>return_period_size</code>. If None (default), calculates as 100 values uniformly spaced within the range of return periods of the extracted extreme values.</p>  <code>None</code>    <code>return_period_size</code>  <code>str or pandas.Timedelta, optional</code>  <p>Size of return periods (default='365.2425D'). If set to '30D', then a return period of 12 would be roughly equivalent to a 1 year return period (360 days).</p>  <code>'365.2425D'</code>    <code>alpha</code>  <code>float, optional</code>  <p>Width of confidence interval (0, 1). If None (default), confidence interval bounds are not plotted.</p>  <code>None</code>    <code>plotting_position</code>  <code>str, optional</code>  <p>Plotting position name (default='weibull'), not case-sensitive. Supported plotting positions: ecdf, hazen, weibull, tukey, blom, median, cunnane, gringorten, beard</p>  <code>'weibull'</code>    <code>figsize</code>  <code>tuple, optional</code>  <p>Figure size in inches in format (width, height). By default it is (8, 8).</p>  <code>(8, 8)</code>    <code>kwargs</code>   <p>Model-specific keyword arguments. If alpha is None, keyword arguments are ignored (error still raised for unrecognized arguments). MLE model: n_samples : int, optional Number of bootstrap samples used to estimate confidence interval bounds (default=100). Emcee model: burn_in : int Burn-in value (number of first steps to discard for each walker).</p>  <code>{}</code>     <p>Returns:</p>    Name Type Description     <code>figure</code>  <code>matplotlib.figure.Figure</code>  <p>Figure object.</p>   <code>axes</code>  <code>tuple</code>  <p>Tuple with four Axes objects: return values, pdf, qq, pp</p>"},{"location":"api/api/#pyextremes.eva.EVA.plot_extremes","title":"<code>plot_extremes(figsize=(8, 5), ax=None, show_clusters=False)</code>","text":"<p>Plot extreme events.</p> <p>Parameters:</p>    Name Type Description Default     <code>figsize</code>  <code>tuple, optional</code>  <p>Figure size in inches in format (width, height). By default it is (8, 5).</p>  <code>(8, 5)</code>    <code>ax</code>  <code>matplotlib.axes._axes.Axes, optional</code>  <p>Axes onto which extremes plot is drawn. If None (default), a new figure and axes objects are created.</p>  <code>None</code>    <code>show_clusters</code>  <code>bool, optional</code>  <p>If True, show cluster boundaries for POT extremes. Has no effect if extremes were extracted using BM method. May produce wrong cluster boundaries if extremes were set using the <code>set_extremes</code> or <code>from_extremes</code> methods and threshold and inter-cluster distance (r) arguments were not provided. By default is False.</p>  <code>False</code>     <p>Returns:</p>    Name Type Description     <code>figure</code>  <code>matplotlib.figure.Figure</code>  <p>Figure object.</p>   <code>axes</code>  <code>matplotlib.axes._axes.Axes</code>  <p>Axes object.</p>"},{"location":"api/api/#pyextremes.eva.EVA.plot_probability","title":"<code>plot_probability(plot_type, return_period_size='365.2425D', plotting_position='weibull', ax=None, figsize=(8, 8))</code>","text":"<p>Plot a probability plot (QQ or PP).</p> <p>Parameters:</p>    Name Type Description Default     <code>plot_type</code>  <code>str</code>  <p>Probability plot type. Supported values: PP - probability plot QQ - quantile plot</p>  required    <code>return_period_size</code>  <code>str or pandas.Timedelta, optional</code>  <p>Size of return periods (default='365.2425D'). If set to '30D', then a return period of 12 would be roughly equivalent to a 1 year return period (360 days).</p>  <code>'365.2425D'</code>    <code>plotting_position</code>  <code>str, optional</code>  <p>Plotting position name (default='weibull'), not case-sensitive. Supported plotting positions: ecdf, hazen, weibull, tukey, blom, median, cunnane, gringorten, beard</p>  <code>'weibull'</code>    <code>ax</code>  <code>matplotlib.axes._axes.Axes, optional</code>  <p>Axes onto which the probability plot is drawn. If None (default), a new figure and axes objects are created.</p>  <code>None</code>    <code>figsize</code>  <code>tuple, optional</code>  <p>Figure size in inches in format (width, height). By default it is (8, 8).</p>  <code>(8, 8)</code>     <p>Returns:</p>    Name Type Description     <code>figure</code>  <code>matplotlib.figure.Figure</code>  <p>Figure object.</p>   <code>axes</code>  <code>matplotlib.axes._axes.Axes</code>  <p>Axes object.</p>"},{"location":"api/api/#pyextremes.eva.EVA.plot_return_values","title":"<code>plot_return_values(return_period=None, return_period_size='365.2425D', alpha=None, plotting_position='weibull', ax=None, figsize=(8, 5), **kwargs)</code>","text":"<p>Plot return values and confidence intervals for given return periods.</p> <p>Parameters:</p>    Name Type Description Default     <code>return_period</code>  <code>array-like, optional</code>  <p>Return period or 1D array of return periods. Given as a multiple of <code>return_period_size</code>. If None (default), calculates as 100 values uniformly spaced within the range of return periods of the extracted extreme values.</p>  <code>None</code>    <code>return_period_size</code>  <code>str or pandas.Timedelta, optional</code>  <p>Size of return periods (default='365.2425D'). If set to '30D', then a return period of 12 would be roughly equivalent to a 1 year return period (360 days).</p>  <code>'365.2425D'</code>    <code>alpha</code>  <code>float, optional</code>  <p>Width of confidence interval (0, 1). If None (default), confidence interval bounds are not plotted.</p>  <code>None</code>    <code>plotting_position</code>  <code>str, optional</code>  <p>Plotting position name (default='weibull'), not case-sensitive. Supported plotting positions: ecdf, hazen, weibull, tukey, blom, median, cunnane, gringorten, beard</p>  <code>'weibull'</code>    <code>ax</code>  <code>matplotlib.axes._axes.Axes, optional</code>  <p>Axes onto which the return value plot is drawn. If None (default), a new figure and axes objects are created.</p>  <code>None</code>    <code>figsize</code>  <code>tuple, optional</code>  <p>Figure size in inches in format (width, height). By default it is (8, 5).</p>  <code>(8, 5)</code>    <code>kwargs</code>   <p>Model-specific keyword arguments. If alpha is None, keyword arguments are ignored (error still raised for unrecognized arguments). MLE model: n_samples : int, optional Number of bootstrap samples used to estimate confidence interval bounds (default=100). Emcee model: burn_in : int Burn-in value (number of first steps to discard for each walker).</p>  <code>{}</code>     <p>Returns:</p>    Name Type Description     <code>figure</code>  <code>matplotlib.figure.Figure</code>  <p>Figure object.</p>   <code>axes</code>  <code>matplotlib.axes._axes.Axes</code>  <p>Axes object.</p>"},{"location":"api/api/#pyextremes.eva.EVA.plot_trace","title":"<code>plot_trace(burn_in=0, labels=None, figsize=None)</code>","text":"<p>Plot trace plot for MCMC sampler trace.</p> <p>Parameters:</p>    Name Type Description Default     <code>burn_in</code>  <code>int, optional</code>  <p>Burn-in value (number of first steps to discard for each walker). By default it is 0 (no values are discarded).</p>  <code>0</code>    <code>labels</code>  <code>array-like, optional</code>  <p>Sequence of strings with parameter names, used to label axes. If None (default), then axes are labeled sequentially.</p>  <code>None</code>    <code>figsize</code>  <code>tuple, optional</code>  <p>Figure size in inches. If None (default), then figure size is calculated automatically as 8 by 2 times number of parameters.</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>figure</code>  <code>matplotlib.figure.Figure</code>  <p>Figure object.</p>   <code>axes</code>  <code>list</code>  <p>List with n_parameters Axes objects.</p>"},{"location":"api/api/#pyextremes.eva.EVA.set_extremes","title":"<code>set_extremes(extremes, **kwargs)</code>","text":"<p>Set extreme values.</p> <p>This method is used to set extreme values onto the model instead of deriving them from data directly using the 'get_extremes' method. This way user can set extremes calculated using a custom methodology.</p> <p>Parameters:</p>    Name Type Description Default     <code>extremes</code>  <code>pd.Series</code>  <p>Time series of extreme values to be set onto the model. Must be numeric, have date-time index, and have the same name as self.data.</p>  required    <code>kwargs</code>   <p>method : str, optional Extreme value extraction method. Supported values: BM (default) - Block Maxima POT - Peaks Over Threshold extremes_type : str, optional high (default) - extreme high values low - extreme low values if method is BM: block_size : str or pandas.Timedelta, optional Block size. If None (default), then is calculated as median distance between extreme events. errors : str, optional raise - raise an exception when encountering a block with no data ignore (default) - ignore blocks with no data coerce - get extreme values for blocks with no data as mean of all other extreme events in the series with index being the middle point of corresponding interval min_last_block : float, optional Minimum data availability ratio (0 to 1) in the last block for it to be used to extract extreme value from. This is used to discard last block when it is too short. If None (default), last block is always used. if method is POT: threshold : float, optional Threshold used to find exceedances. By default is taken as smallest value. r : pandas.Timedelta or value convertible to timedelta, optional Duration of window used to decluster the exceedances. By default r='24H' (24 hours). See pandas.to_timedelta for more information.</p>  <code>{}</code>"},{"location":"user-guide/1-read-first/","title":"Read First","text":""},{"location":"user-guide/1-read-first/#disclaimer","title":"Disclaimer","text":"<p>pyextremes was created to make the process of running EVA simpler and faster. While the project is built with reasonable defaults which produce good results in most cases, one should not rely on the model as a source of ground truth. It is always the responsibility of the user to understand the subject of analysis and to properly interpret the model outputs.</p>  <p>Example</p> <p>A 1000-year wave height of 100 meters is not physical and is an artifact of the underlying statistical model. One should always be mindful of the actual process being modeled and remember that the model gives a proabilistic estimate of extreme values under the assumption that the selected model (e.g. GEVD or GPD) correctly describes the underlying process (in this example, water waves).</p>"},{"location":"user-guide/1-read-first/#tutorial-structure","title":"Tutorial Structure","text":"<p>Each tutorial section covers a particular area of EVA, such as extreme value extraction, fitting a model, or summarizing and visualizing analysis results. pyextremes was built in a modular fashion where each of these components is implemented independently and can be used on its own. In order to make life easier a helper class <code>EVA</code> was created (located in <code>pyextremes.eva.EVA</code>) which chains these components together to streamline the most common types of EVA workflows and to reduce the amount of code a user needs to write when performing analysis.</p> <p>When possible, sections of this tutorial present two alternative ways to perform the same action: via <code>EVA</code> and via low-level functions which are using by <code>EVA</code> behind the scenes.</p>"},{"location":"user-guide/10-selecting-distribution/","title":"10 selecting distribution","text":"<p>GEVD and GPD, degeneracy, model comparison (AIC, likelihood ratio).</p>"},{"location":"user-guide/11-return-values/","title":"11 return values","text":"<p>Discrete return values and summary.</p>"},{"location":"user-guide/13-visualization/","title":"13 visualization","text":"<p>Diagnostic and its components.</p>"},{"location":"user-guide/14-goodness-of-fit/","title":"14 goodness of fit","text":"<p>Kolmogorov-Smirnov and other (WIP).</p>"},{"location":"user-guide/2-extreme-value-types/","title":"Extreme Value Types","text":"<p>Traditionally EVA recognizes two types of extreme values:</p> <ul> <li>Block maxima (BM)</li> <li>Peaks over threshold (POT)</li> </ul> <p>The BM and POT extreme values are used to apply a statistical model (GEVD or GPD accordingly) to allow for estimation of extreme events of an arbitrary probability of exceedance (return period). Both of these extreme value types represent a valid path of performing EVA and neither of these is generally better than another.</p>  <p>Info</p> <p>GEVD and GPD models used for BM and POT extreme value types accordingly have a common theoretical basis and should be treated as complementary models, not as either/or. More information about why only the GEVD and GPD models are recommended to be used is provided in subsequent sections of this tutorial.</p>"},{"location":"user-guide/2-extreme-value-types/#block-maxima","title":"Block Maxima","text":"<p>The Block Maxima extreme values are extracted by selecting a block size (typically 1 year, also the default in pyextremes), then partitioning time series of your signal into equal consequtive blocks of this size, and for each block getting single maximum value (thus, block maxima). The resulting BM time series are then used to model extreme value behavior using the GEVD model family. See figure below illustrating this concept:</p>"},{"location":"user-guide/2-extreme-value-types/#peaks-over-threshold","title":"Peaks Over Threshold","text":"<p>The Peaks Over Threshold extreme values are extracted by choosing a threshold and selecting values higher or lower (depends on which extreme process is analyzed) than the threshold value. The selected values are then declustered by specifying minimum distance between adjacent clusters (e.g. 24 hours, which means that the model assumes that clusters of exceedances separater by this distiance or larger are independent). Selection of threshold and declustering distance is not a trivial task and has a strong effect on the EVA results. pyextremes provides a series of tools which help with threshold selection, these are described further in this tutorial. See figure below illustrating POT extremes:</p>"},{"location":"user-guide/2-extreme-value-types/#which-method-to-use","title":"Which Method to Use","text":"<p>One of the most important concepts of EVA is convergenece. What this means practically is that different models and approaches (as long as they are correctly applied) should  be converging to the same answer (within reasonable confidence limits). Because of this, we cannot say that one method is better than another. Therefore, for a thorough analysis, user is advised to investigate both routes to make sure that the final answer of the analysis provides a robust estimate.</p> <p>A general rule of thumb, which is based on years of author's (subjective) experience, when performing EVA is to do the following:</p> <ul> <li>Use BM with a reasonable block size to avoid capturing seasonality (read more in the next section) to get the first estimates and to see how the extremes behave. Generally, BM is a \"simpler\" and more stable model which requires very little input from the user.</li> <li>Use POT with a reasonable threshold and declustering parameters (read more in the next section) to investigate how stable the model is in the region of target exceedance probabilities (return periods) and to gain more confidence in your results.</li> </ul>  <p>Attention</p> <p>User is strongly discouraged from \"playing\" with the model parameters until a desired answer is achieved. EVA is not about getting a perfect estimate and a lack of a definitive answer is an answer in itself - it signifies that underlying process may be not random (e.g. seasonality or some trends were not removed prior to performing EVA), that the model is poorly behaved for the data, or that there is simply not enough data to provide an accurate answer for a given probability. This is typically reflected by wide confidence intervals showing that the answer has high uncertainty. For example, your 100-year wind speed may be 50 knots (seems reasonable, right?) but the 95% confidence interval shows 10 to 120 knot uncertainty range - this clearly indicates that, while your answer happened to appear reasonable, the model is telling you that you cannot make any good faith judgement about the 100-year extreme event when using this data and methodology.</p>"},{"location":"user-guide/3-block-maxima/","title":"Block Maxima","text":"<p>Block Maxima or Minima (BM) extreme values are extracted from time series by partitioning it into blocks (segments) of equal duration (e.g. 1 year) and locating maximum or minimum values within each block. Block maxima extreme values asymptotically follow the Generalized Extreme Value Distribution family, according to the Fisher\u2013Tippett\u2013Gnedenko theorem. This theorem demonstrates that the GEVD family is the only possible limit for the block maxima extreme values.</p>"},{"location":"user-guide/3-block-maxima/#extracting-extremes","title":"Extracting Extremes","text":"<p>As outlined in the Read First section of this documentation, there are multiple ways the same thing can be achieved in <code>pyextremes</code>. The BM extraction function can be accessed via:</p> <ul> <li><code>pyextremes.extremes.block_maxima.get_extremes_block_maxima</code> - the lowest level</li> <li><code>pyextremes.get_extremes</code> - general-purpose extreme value extraction function</li> <li><code>pyextremes.EVA.get_extremes</code> - helper-class   (extreme values are not returned by this function, but instead are set   on the <code>EVA</code> instance in the <code>.extremes</code> attribute)</li> </ul> <p>The simplest way to extract extreme values using BM method is to use the default parameters of the <code>get_extremes</code> function:</p> Standalone <pre><code>from pyextremes import get_extremes\nfrom pyextremes.plotting import plot_extremes\n\nextremes = get_extremes(data, \"BM\")\nplot_extremes(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"BM\",\n    extremes_type=\"high\",\n    block_size=\"365.2425D\",\n)\n</code></pre>  Using EVA <pre><code>from pyextremes import EVA\n\nmodel = EVA(data=data)\nmodel.get_extremes(\"BM\")\nmodel.plot_extremes()\n</code></pre>       Note <p>You can get the <code>data</code> variable referenced above by running the following code:</p> <pre><code>data = pd.read_csv(\n    \"battery_wl.csv\",\n    index_col=0,\n    parse_dates=True,\n).squeeze()\ndata = (\n    data\n    .sort_index(ascending=True)\n    .astype(float)\n    .dropna()\n    .loc[pd.to_datetime(\"1980\"):pd.to_datetime(\"1995\")]\n)\ndata = (\n  data - (data.index.array - pd.to_datetime(\"1992\"))\n) / pd.to_timedelta(\"365.2425D\") * 2.87e-3\n</code></pre> <p><code>\"battery_wl.csv\"</code> can be downloaded here.</p> <p>All figures shown in this tutorial section were generated using this jupyter notebook.</p>  <p>The <code>get_extremes</code> function uses the following parameters:</p> <ul> <li>ts - time series (<code>pandas.Series</code>) from which the extreme values are extracted</li> <li>method - extreme value extraction method: <code>\"BM\"</code> for Block Maxima   and <code>\"POT\"</code> for Peaks Over Threshold.</li> <li>extremes_type - extreme value type:   <code>\"high\"</code> for maxima (default) and <code>\"low\"</code> for minima</li> </ul> <p>The following paramters are used only when <code>method=\"BM\"</code>:</p> <ul> <li>block_size - block size, by default <code>\"365.2425D\"</code>.   Internally is converted using the <code>pandas.to_timedelta</code> function.</li> <li>errors - specifies what to do when a block is empty (has no values).   <code>\"raise\"</code> (default) raises error, <code>\"ignore\"</code> skips such blocks   (not recommended), and <code>\"coerce\"</code> sets values for such blocks as average   of extreme values in other blocks.</li> <li>min_last_block - minimum data availability ratio (0 to 1)   in the last block. If the last block is shorter than this ration   (e.g. 0.25 corresponds to 3 months for a block size of 1 year) then it is not used   to get extreme values. This argument is useful to avoid situations when the last   block is very small. By default this is <code>None</code>, which means that last   block is always used.</li> </ul> <p>If we specify all of these parameters then the function would look as:</p> <pre><code>get_extremes(\n    ts=data,\n    method=\"BM\",\n    extremes_type=\"high\",\n    block_size=\"365.2425D\",\n    errors=\"raise\",\n    min_last_block=None,\n)\n</code></pre>"},{"location":"user-guide/3-block-maxima/#selecting-block-size","title":"Selecting Block Size","text":"<p>Like with most choices in statistics, selection of block size involves making a trade-off between bias and variance: blocks that are too small mean that approximation by the limit model (GEVD) is likely to be poor, leading to bias in estimation and extrapolation; large blocks generate few block maxima/minima, leading to large estimation variance. Pragmatic considerations often lead to the adoption of blocks of length one year. (Coles, 2004)</p> <p>An important thing to consider is also the physical nature of investigated signal. Many meteorological events (e.g. snowfall, rain, waves) are seasonal and, therefore, selection of block sizes smaller than 1-year would result in significant bias due to blocks no longer being equivalent (e.g. summer blocks are nearly guaranteed to have no snow).</p> <p>We can specify different block size using the <code>block_size</code> argument. Using the same data as above but with a block size of 2 years we get:</p> Standalone <pre><code>extremes = get_extremes(\n    ts=data,\n    method=\"BM\",\n    block_size=pd.to_timedelta(\"365.2425D\") * 2,\n)\nplot_extremes(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"BM\",\n    extremes_type=\"high\",\n    block_size=pd.to_timedelta(\"365.2425D\") * 2,\n)\n</code></pre>  Using EVA <pre><code>model = EVA(data=data)\nmodel.get_extremes(\"BM\", block_size=pd.to_timedelta(\"365.2425D\") * 2)\nmodel.plot_extremes()\n</code></pre>"},{"location":"user-guide/3-block-maxima/#block-minima","title":"Block Minima","text":"<p>Block minima is fully equivalent to block maxima in the way it is extracted. Block minima can be extracted by setting the <code>extremes_type</code> argument to <code>\"low\"</code>:</p> Standalone <pre><code>extremes = get_extremes(\n    ts=data,\n    method=\"BM\",\n    extremes_type=\"low\",\n)\nplot_extremes(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"BM\",\n    extremes_type=\"high\",\n    block_size=\"365.2425D\",\n)\n</code></pre>  Using EVA <pre><code>model = EVA(data=data)\nmodel.get_extremes(\"BM\", extremes_type=\"low\")\nmodel.plot_extremes()\n</code></pre>       <p>Tip</p> <p>The <code>pyextremes.EVA</code> class works identically for both maxima and minima series and properly reflects (rotates) the data to fit statistical distributions. This is true as long as the <code>extremes_type</code> argument is correctly specified.</p>   <p>Warning</p> <p>When analyzing block minima be mindful of your data being censored. An example of this would be water level time series - water levels cannot go below the seabed and will, therefore, be censored by the seabed elevation. Such series would no longer follow the GEVD and any results of such analysis would be unerliable.</p>"},{"location":"user-guide/4-peaks-over-threshold/","title":"Peaks Over Threshold","text":"<p>Peaks Over Threshold (POT) extreme values are extracted from time series by first generating a time series of exceedances by selecting values above (or below for <code>extremes_type=\"low\"</code>) a certain threshold and then declustering the exceedance time series by identifying clusters separated by a given time period and then selecting only the highest (lowest) values within each cluster. Declustering is performed in order to ensure that these values are IID (independent and identically distributed) which is required for the corresponding limit distribution to be applicable. The POT extreme values asymptotically follow the Generalized Pareto Distribution famliy, according to the Pickands\u2013Balkema\u2013De Haan theorem.</p>"},{"location":"user-guide/4-peaks-over-threshold/#extracting-extremes","title":"Extracting Extremes","text":"<p>As outlined in the Read First section of this documentation, there are multiple ways the same thing can be achieved in <code>pyextremes</code>. The POT extraction function can be accessed via:</p> <ul> <li><code>pyextremes.extremes.peaks_over_threshold.get_extremes_peaks_over_threshold</code> - the lowest level</li> <li><code>pyextremes.get_extremes</code> - general-purpose extreme value extraction function</li> <li><code>pyextremes.EVA.get_extremes</code> - helper-class   (extreme values are not returned by this function, but instead are set   on the <code>EVA</code> instance in the <code>.extremes</code> attribute)</li> </ul> <p>The simplest way to extract extreme values using BM method is to use the default parameters of the <code>get_extremes</code> function:</p> Standalone <pre><code>from pyextremes import get_extremes\nfrom pyextremes.plotting import plot_extremes\n\nextremes = get_extremes(data, \"POT\", threshold=0.5, r=\"12H\")\nplot_extremes(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"POT\",\n    extremes_type=\"high\",\n    threshold=0.5,\n    r=\"12H\",\n)\n</code></pre>  Using EVA <pre><code>from pyextremes import EVA\n\nmodel = EVA(data=data)\nmodel.get_extremes(\"POT\", threshold=0.5, r=\"12H\")\nmodel.plot_extremes(show_clusters=True)\n</code></pre>       Note <p>You can get the <code>data</code> variable referenced above by running the following code:</p> <pre><code>data = pd.read_csv(\n    \"battery_wl.csv\",\n    index_col=0,\n    parse_dates=True,\n).squeeze()\ndata = (\n    data\n    .sort_index(ascending=True)\n    .astype(float)\n    .dropna()\n    .loc[pd.to_datetime(\"1980/01/01\"):pd.to_datetime(\"1980/01/20\")]\n)\ndata = (\n  data - (data.index.array - pd.to_datetime(\"1992\"))\n) / pd.to_timedelta(\"365.2425D\") * 2.87e-3\n</code></pre> <p><code>\"battery_wl.csv\"</code> can be downloaded here.</p> <p>All figures shown in this tutorial section were generated using this jupyter notebook.</p>  <p>The <code>get_extremes</code> function uses the following parameters:</p> <ul> <li>ts - time series (<code>pandas.Series</code>) from which the extreme values are extracted</li> <li>method - extreme value extraction method: <code>\"BM\"</code> for Block Maxima   and <code>\"POT\"</code> for Peaks Over Threshold.</li> <li>extremes_type - extreme value type:   <code>\"high\"</code> for above threshold (default)   and <code>\"low\"</code> for below threshold.</li> </ul> <p>The following paramters are used only when <code>method=\"POT\"</code>:</p> <ul> <li>threshold - threshold value.</li> <li>r - minimum time distance (window duration) between adjacent clusters. Used   to decluster exceedances by locating clusters where all exceedances are separated   by distances no more than <code>r</code> and then locating maximum or minimum   (depends on <code>extremes_type</code>) values within each cluster.   By default <code>r=\"24H\"</code> (24 hours).</li> </ul> <p>If we specify all of these parameters then the function would look as:</p> <pre><code>get_extremes(\n    ts=data,\n    method=\"POT\",\n    extremes_type=\"high\",\n    threshold=0.5,\n    r=\"12H\",\n)\n</code></pre>"},{"location":"user-guide/4-peaks-over-threshold/#declustering","title":"Declustering","text":"<p>As described earlier, declustering is controlled using the <code>r</code> argument. The goal of declustering is to ensure that all extreme values are IID, which is a requirement for the GPD model to be valid. Shown below is an example of extremes extracted from the same data and using the same threshold as above, but with a larger <code>r</code> value:</p> Standalone <pre><code>extremes = get_extremes(data, \"POT\", threshold=0.5, r=\"24H\")\nplot_extremes(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"POT\",\n    extremes_type=\"high\",\n    threshold=0.5,\n    r=\"24H\",\n)\n</code></pre>  Using EVA <pre><code>model = EVA(data=data)\nmodel.get_extremes(\"POT\", threshold=0.5, r=\"24H\")\nmodel.plot_extremes(show_clusters=True)\n</code></pre>       <p>Tip</p> <p>Declustering value of <code>r=\"24H\"</code> was selected as a default value because <code>pyextremes</code> was developed when working with meteorological phenomena - namely, storms. Extreme storm surge and waves are generally caused by a storm event which generally doesn't exceed 12-24 hours and, because of this, the assumption of 24-hour inter-cluster distance results in a reasonably good separation of independent storm events.</p> <p>User is advised to select this parameter based on the properties of studied phenomena. For example, extreme precipitation events in some regions of the world can last for more than several days and, because of this, the default value of 24 hours would not be adequate for such analysis.</p>"},{"location":"user-guide/4-peaks-over-threshold/#peaks-below-threshold","title":"Peaks Below Threshold","text":"<p>A special case of Peaks Over Threshold is when instead of selecting values above the threshold we select values below it. Such values can be extracted by setting the <code>extremes_type</code> argument to <code>\"low\"</code>:</p> Standalone <pre><code>extremes = get_extremes(\n    data,\n    \"POT\",\n    threshold=0.5,\n    r=\"24H\",\n    extremes_type=\"low\",\n)\nplot_extremes(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"POT\",\n    extremes_type=\"low\",\n    threshold=0.5,\n    r=\"24H\",\n)\n</code></pre>  Using EVA <pre><code>model = EVA(data=data)\nmodel.get_extremes(\"POT\", threshold=0.5, r=\"24H\", extremes_type=\"low\")\nmodel.plot_extremes(show_clusters=True)\n</code></pre>       <p>Tip</p> <p>The <code>pyextremes.EVA</code> class works identically for both peaks over and below threshold series and properly reflects (rotates) the data to fit statistical distributions. This is true as long as the <code>extremes_type</code> argument is correctly specified.</p>   <p>Warning</p> <p>When analyzing POT with <code>extremes_type=\"low\"</code> be mindful of your data being censored. An example of this would be water level time series - water levels cannot go below the seabed and will, therefore, be censored by the seabed elevation. Such series would no longer follow the GPD and any results of such analysis would be unerliable.</p>"},{"location":"user-guide/5-threshold-selection/","title":"Threshold Selection","text":"<p>Selection of the threshold value is a very important step because it has the strongest effect on the results of EVA. The core idea of threshold selection is the same as when selecting block size in the Block Maxima approach - it is a trade-off between bias and variance. Larger threshold values produce few extreme values and lead to large variance in result (confidence bounds), while smaller threshold values generate a sample which poorly approximates the GPD model. The opposite is true when performing EVA for extreme low values (<code>extremes_type=\"low\"</code>).</p> <p>The key goal of threshold selection can, therefore, be formulated as follows:</p>  <p>Goal of threshold selection</p>  <p>Select the smallest threshold value among those which produce extreme values following the limit exceedance model (Generalized Pareto Distribution family).</p>  <p>Warning</p> <p>Threshold selection is probably the hardest part of Extreme Value Analysis when analyzing extreme values obtained using the Peaks Over Threshold method. It involves a great deal of subjective judgement and should be performed in conjunction with other methods, such as Block Maxima + GEVD, to gain more confidence in the validty of obtained results.</p>"},{"location":"user-guide/5-threshold-selection/#mean-residual-life","title":"Mean Residual Life","text":"<p>Mean residual life plot plots average excess value over given threshold for a series of thresholds. The idea is that the mean residual life plot should be approximately linear above a threshold for which the Generalized Pareto Distribution model is valid.</p> <pre><code>from pyextremes import plot_mean_residual_life\n\nplot_mean_residual_life(data)\n</code></pre>     Note <p>You can get the <code>data</code> variable referenced above by running the following code:</p> <pre><code>data = pd.read_csv(\n    \"battery_wl.csv\",\n    index_col=0,\n    parse_dates=True,\n).squeeze()\ndata = (\n    data\n    .sort_index(ascending=True)\n    .astype(float)\n    .dropna()\n    .loc[pd.to_datetime(\"1925\"):]\n)\ndata = (\n  data - (data.index.array - pd.to_datetime(\"1992\"))\n) / pd.to_timedelta(\"365.2425D\") * 2.87e-3\n</code></pre> <p><code>\"battery_wl.csv\"</code> can be downloaded here.</p> <p>All figures shown in this tutorial section were generated using this jupyter notebook.</p>  <p>As seen in the figure above, exceedance values are approximately linear between threshold values of 1.2 and 1.8. This provides a range of threshold values which can be further investigated using other methods.</p> <p>The <code>plot_mean_residual_life</code> function uses the following parameters:</p> <ul> <li>ts - time series (<code>pandas.Series</code>) from which the extreme values are extracted</li> <li>thresholds - array of threshold for which the plot is displayed. By default   100 equally-spaced thresholds between 90th (10th if <code>extremes_type=\"high\"</code>)   percentile and 10th largest (smallest if <code>extremes_type=\"low\"</code>)   value in the series.</li> <li>extremes_type - extreme value type:   <code>\"high\"</code> for above threshold (default)   and <code>\"low\"</code> for below threshold.</li> <li>alpha - confidence interval width in the range (0, 1), by default it is 0.95.   If None, then confidence interval is not shown.</li> <li>ax - matplotlib Axes object. If provided, then the plot is drawn on this axes.   If None (default), new figure and axes are created</li> <li>figsize - figure size in inches in format (width, height).   By default it is (8, 5).</li> </ul>  <p>Note</p> <p>In author's (subjective) opinion this is the least useful technique among those listed in this section because mean residual life plots are very hard to interpret.</p>"},{"location":"user-guide/5-threshold-selection/#parameter-stability","title":"Parameter Stability","text":"<p>Parameter stability plot shows how shape and modified scale parameters of the Generalized Pareto Distribution change over a range of threshold values. The idea is that these parameters should be stable (vary by small amount) within a range of valid thresholds.</p> <pre><code>from pyextremes import plot_parameter_stability\n\nplot_parameter_stability(data)\n</code></pre>    <p>As seen in the figure above, these parameters appear to stabilize around threshold value of 1.2 with subsequent values having higher variance due to smaller number of exceedances.</p> <p>The <code>plot_parameter_stability</code> function uses the following parameters:</p> <ul> <li>ts - time series (<code>pandas.Series</code>) from which the extreme values are extracted</li> <li>thresholds - array of threshold for which the plot is displayed. By default   100 equally-spaced thresholds between 90th (10th if <code>extremes_type=\"high\"</code>)   percentile and 10th largest (smallest if <code>extremes_type=\"low\"</code>)   value in the series.</li> <li>r - minimum time distance (window duration) between adjacent clusters. Used   to decluster exceedances by locating clusters where all exceedances are separated   by distances no more than <code>r</code> and then locating maximum or minimum   (depends on <code>extremes_type</code>) values within each cluster.   By default <code>r=\"24H\"</code> (24 hours).</li> <li>extremes_type - extreme value type:   <code>\"high\"</code> for above threshold (default)   and <code>\"low\"</code> for below threshold.</li> <li>alpha - confidence interval width in the range (0, 1), by default it is 0.95.   If None, then confidence interval is not shown.</li> <li>n_samples - number of bootstrap samples used to estimate confidence   interval bounds (default=100). Ignored if <code>alpha</code> is None.</li> <li>axes - tuple with matplotlib Axes (ax_shape, ax_scale) for shape and scale values.   If None (default), new figure and axes are created.</li> <li>figsize - figure size in inches in format (width, height).   By default it is (8, 5).</li> <li>progress - if True, shows tqdm progress bar. By default False.   Requires <code>tqdm</code> package.</li> </ul>"},{"location":"user-guide/5-threshold-selection/#return-value-stability","title":"Return Value Stability","text":"<p>An extension of the previous technique is to investigate stability of a target return value with a pre-defined return period over a range of thresholds. This technique provides a more intuitive metric of model stability. Let's plot it for the range of thresholds identified earlier:</p> <pre><code>from pyextremes import plot_return_value_stability\n\nplot_return_value_stability(\n    data,\n    return_period=100,\n    thresholds=np.linspace(1.2, 1.8, 20),\n    alpha=0.95,\n)\n</code></pre>    <p>As seen in the figure above, the model is very stable for threshold values above 1.4.</p> <p>The <code>plot_return_value_stability</code> function uses the following parameters:</p> <ul> <li>ts - time series (<code>pandas.Series</code>) from which the extreme values are extracted</li> <li>return_period - return period given as a multiple of <code>return_period_size</code>.</li> <li>return_period_size - size of return period. Same as the <code>r</code> argument.   By default this is 1 year.</li> <li>thresholds - array of threshold for which the plot is displayed. By default   100 equally-spaced thresholds between 90th (10th if <code>extremes_type=\"high\"</code>)   percentile and 10th largest (smallest if <code>extremes_type=\"low\"</code>)   value in the series.</li> <li>r - minimum time distance (window duration) between adjacent clusters. Used   to decluster exceedances by locating clusters where all exceedances are separated   by distances no more than <code>r</code> and then locating maximum or minimum   (depends on <code>extremes_type</code>) values within each cluster.   By default <code>r=\"24H\"</code> (24 hours).</li> <li>extremes_type - extreme value type:   <code>\"high\"</code> for above threshold (default)   and <code>\"low\"</code> for below threshold.</li> <li>distributions - list of distributions for which the plot is produced.   By default these are \"genpareto\" and \"expon\".   A distribution must be either a name of distribution from <code>scipy.stats</code>   or a subclass of scipy.stats.rv_continuous.   See scipy.stats documentation</li> <li>alpha - confidence interval width in the range (0, 1), by default it is 0.95.   If None, then confidence interval is not shown.</li> <li>n_samples - number of bootstrap samples used to estimate confidence   interval bounds (default=100). Ignored if <code>alpha</code> is None.</li> <li>ax - matplotlib Axes object. If provided, then the plot is drawn on this axes.   If None (default), new figure and axes are created</li> <li>figsize - figure size in inches in format (width, height).   By default it is (8, 5).</li> <li>progress - if True, shows tqdm progress bar. By default False.   Requires <code>tqdm</code> package.</li> </ul>  <p>Warning</p> <p>This is the most dangerous threshold selection teqchnique presented in this section. It can be abused by selecting a threshold value which gives a desired result. Results of such analysis would be biased and invalid. Analyst should honestly present results of their analysis and high variance in answer should be considered a valuable result as well - it indicates that available data cann be used to obtain reliable results and that there is high uncertainty in the analyzed process.</p>"},{"location":"user-guide/5-threshold-selection/#putting-it-all-together","title":"Putting it all Together","text":"<p><code>pyextremes</code> provides a convenience function to put all of the above together. It also adds an additional plot - AIC curve indicating relative model performance. The AIC curve should not be used as a threshold selection tool because it will always have the same logarithmic shape. Instead, it should guide the user as to which model (e.g. GEVD or Exponential) should be preferred for a given threshold.</p> <pre><code>from pyextremes import plot_threshold_stability\n\nplot_threshold_stability(\n    data,\n    return_period=100,\n    thresholds=np.linspace(1.2, 1.8, 20),\n)\n</code></pre>    <p>Based on the figures shown earlier, one may conclude that the valid threshold may lie between 1.4 and 1.6. A decision was made to select threshold value of 1.5.</p> <p>The <code>plot_threshold_stability</code> function uses the following parameters:</p> <ul> <li>ts - time series (<code>pandas.Series</code>) from which the extreme values are extracted</li> <li>return_period - return period given as a multiple of <code>return_period_size</code>.</li> <li>return_period_size - size of return period. Same as the <code>r</code> argument.   By default this is 1 year.</li> <li>thresholds - array of threshold for which the plot is displayed. By default   100 equally-spaced thresholds between 90th (10th if <code>extremes_type=\"high\"</code>)   percentile and 10th largest (smallest if <code>extremes_type=\"low\"</code>)   value in the series.</li> <li>r - minimum time distance (window duration) between adjacent clusters. Used   to decluster exceedances by locating clusters where all exceedances are separated   by distances no more than <code>r</code> and then locating maximum or minimum   (depends on <code>extremes_type</code>) values within each cluster.   By default <code>r=\"24H\"</code> (24 hours).</li> <li>extremes_type - extreme value type:   <code>\"high\"</code> for above threshold (default)   and <code>\"low\"</code> for below threshold.</li> <li>distributions - list of distributions for which the plot is produced.   By default these are \"genpareto\" and \"expon\".   A distribution must be either a name of distribution from <code>scipy.stats</code>   or a subclass of scipy.stats.rv_continuous.   See scipy.stats documentation</li> <li>alpha - confidence interval width in the range (0, 1), by default it is 0.95.   If None, then confidence interval is not shown.</li> <li>n_samples - number of bootstrap samples used to estimate confidence   interval bounds (default=100). Ignored if <code>alpha</code> is None.</li> <li>ax - matplotlib Axes object. If provided, then the plot is drawn on this axes.   If None (default), new figure and axes are created</li> <li>figsize - figure size in inches in format (width, height).   By default it is (8, 5).</li> <li>progress - if True, shows tqdm progress bar. By default False.   Requires <code>tqdm</code> package.</li> </ul> <p>Results of selecting the threshold value 1.5 are shown below:</p>"},{"location":"user-guide/6-return-periods/","title":"Estimating Return Periods","text":"<p>This section demonstrates how empirical probabilities (return periods) can be obtained for extreme values extracted using methods described in earlier sections.</p>"},{"location":"user-guide/6-return-periods/#what-is-return-period","title":"What is Return Period","text":"<p>Return period indicates duration of time (typically years) which corresponds to a probability that a given value (e.g. wind speed) would be exceeded at least once within a year. This probability is called probability of exceedance and is related to return periods as <code>1/p</code> where <code>p</code> is return period.</p>  <p>Coles (2001, p.49)</p>  <p>In common terminology, \\(z_{p}\\) is the return level associated with the return period \\(1/p\\), since to a reasonable degree of accuracy, the level \\(z_{p}\\) is expected to be exceeded on average once every \\(1/p\\) years. More precisely, \\(z_{p}\\) is exceeded by the annual maximum in any particular year with probability \\(p\\).</p> <p>Return periods are often incorrectly interpreted in the professional communities as \"100-year event is an event which happens only once in 100 years\", which may lead to inaccurate assessment of risks. A more holistic way of looking at this is to consider a time period within which a risk is evaluated. For example, a 100-year event with probability of exceedance in any given year of 1% would have a probability of ~39.5% to be exceeded at least once within 50 years - this is calculated using this formula:</p> \\[1 - (1 - p) ^ n\\] <p>Where \\(n\\) is number of return period blocks within a time period (50 for 50 years with retun period block of size 1 year) and \\(p\\) is 1% (100-year event).</p>"},{"location":"user-guide/6-return-periods/#empirical-return-periods","title":"Empirical Return Periods","text":"<p>Empirical return periods are assigned to observed extreme values using an empricial rule where extreme values are ordered and ranked from the most extreme (1) to the least extreme (n), then exceedance probabilities are calculated (see the following sub-section), and return periods are calculated as multiples of a given <code>return_period_size</code> (typically 1 year).</p>"},{"location":"user-guide/6-return-periods/#probability-of-exceedance","title":"Probability of Exceedance","text":"<p>Extreme events extracted using BM or POT methods are assigned exceedance probabilities using the following formula:</p> \\[P = \\frac{r - \\alpha}{n + 1 - \\alpha - \\beta}\\] <p>where:</p> <ul> <li>r - rank of extreme value (1 to n). In <code>pyextremes</code> rank is calculated using   <code>scipy.stats.rankdata</code> with <code>method=\"average\"</code>, which means that extreme   events of the same magnitude are assigned average of ranks these values would be   assigned otherwise if ranked sequentially. For example, array of <code>[1, 2, 3, 3, 4]</code>   would have ranks of <code>[5, 4, 2.5, 2.5, 1]</code>.</li> <li>n - number of extreme values.</li> <li>\\(\\alpha\\) and \\(\\beta\\) - empricial plotting position parameters (see further below).</li> </ul> <p>In this context \\(P\\) corresponds to a probability of exceedance of a value with rank r in a any given time period with duration \\(t/n\\) where \\(t\\) is total duration of series from which the extreme values were drawn and \\(n\\) is number of extreme events. If we measure time in years and we use Block Maxima with block size of 1 year, then the formula \\(t/n\\) becomes 1 by definition and the return period in years can be calculated as \\(1/P\\). For general rule read this tutorial section further.</p>"},{"location":"user-guide/6-return-periods/#plotting-positions","title":"Plotting Positions","text":"<p>Plotting positions are sets of empirical coefficients defining how extreme values are assigned probabilities, which are subsequently used to plot extreme values on the probability plots.</p>  <p>Warning</p> <p>Plotting positions have nothing to do with modeling extreme event statistics in modern EVA. Historically, in time before computers became widespread, EVA was performed by plotting extreme events on probability paper (with axes scaled logarithmically and according to a specific plotting position) with the idea that a return value curve for a given model (e.g. GEVD) would be a straight line drawn through these points using a pen and a ruler.</p> <p>Modern EVA fits models to data by maximimizng likelihood function via methods such as MLE or MCMC (read more in other sections). This is only feasible due to the use of computers and would be prohibitively expensive to do manually. Plotting positions are presently used only to show extreme values on return value plots and to perform some goodness-of-fit tests (e.g. P-P or Q-Q plots).</p> <p>TL;DR: plotting positions are NOT used to fit models.</p>  <p>An example of plotting positions used in <code>pyextremes</code> is the diagnostic plot where observed extreme values (black dots) are superimposed against the theoretical estimates (by fitting a distribution) as seen in the return value, Q-Q, and P-P plots.</p>"},{"location":"user-guide/6-return-periods/#return-period","title":"Return Period","text":"<p>Return periods are calculated from the exceedance probabilities using the following formula:</p> \\[R = 1 / P / \\lambda\\] <p>where:</p> <ul> <li>R - return period as multiple of <code>return_period_size</code> (by default 1 year).</li> <li>P - exceedance probability calculated earlier.</li> <li>\\(\\lambda\\) - rate of extreme events (average number of extreme events per   <code>return_period_size</code>). Calculated as:</li> <li>\\(\\lambda\\) = <code>return_period_size</code> / <code>block_size</code> for Block Maxima</li> <li>\\(\\lambda = \\frac{n}{t / return\\_period\\_size}\\) for Peaks Ove Threshold,     where \\(n\\) is number of extreme events and \\(t\\) is total duration of series     from which the extreme values were drawn</li> </ul> <p>The resulting return period R is, therefore, a real number representing a multiple of <code>return_period_size</code>.</p>  <p>Example</p> <p>We have 2 years of data and, using <code>block_size</code> of 30 days (~1 month), we extract 24 extreme events using the Block Maxima method. We then rank the values from 1 to 24 as outlined above and, using the Weibull plotting position (\\(\\alpha=0\\) and \\(\\beta=0\\)), for the most extreme value (rank 1) we get exceedance probability \\(P\\) of 1/25 or 0.04.</p> <p>Let's say we would like to get return period of the most extreme value (rank 1) in years (<code>return_period_size</code> of 1 year). First, we calculate extreme value rate \\(\\lambda\\) as <code>return_period_size</code> / <code>block_size</code>, which gives us 12 (approximately since we used 30 days for <code>block_size</code>). Now we can use the return period formula above directly as \\(R = 1 / 0.04 / 12 = 2.08\\) years.</p>"},{"location":"user-guide/6-return-periods/#estimating-return-periods","title":"Estimating Return Periods","text":"<p><code>pyextremes</code> estimates empirical return periods for many plotting functions and goodness-of-fit tests behind the scenes using the Weibull plotting position. Return periods can be calculated using the <code>get_return_periods</code> function (shown only for Block Maxima; Peaks Over Threshold works identically with the only difference being the <code>block_size</code> argument):</p> weibull (default) <pre><code>from pyextremes import get_extremes, get_return_periods\n\nextremes = get_extremes(\n    ts=data,\n    method=\"BM\",\n    block_size=\"365.2425D\",\n)\nreturn_periods = get_return_periods(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"BM\",\n    extremes_type=\"high\",\n    block_size=\"365.2425D\",\n    return_period_size=\"365.2425D\",\n    plotting_position=\"weibull\",\n)\nreturn_periods.sort_values(\"return period\", ascending=False).head()\n</code></pre>    Date-Time (GMT) Water Elevation [m NAVD88] exceedance probability return period     2012-10-30 01:00:00 3.357218 0.010526 95.000000   1960-09-12 18:00:00 2.295832 0.021053 47.500000   1992-12-11 14:00:00 2.108284 0.031579 31.666667   1953-11-07 12:00:00 2.101487 0.042105 23.750000   1950-11-25 14:00:00 2.012957 0.052632 19.000000     median <pre><code>from pyextremes import get_extremes, get_return_periods\n\nextremes = get_extremes(\n    ts=data,\n    method=\"BM\",\n    block_size=\"365.2425D\",\n)\nreturn_periods = get_return_periods(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"BM\",\n    extremes_type=\"high\",\n    block_size=\"365.2425D\",\n    return_period_size=\"365.2425D\",\n    plotting_position=\"median\",\n)\nreturn_periods.sort_values(\"return period\", ascending=False).head()\n</code></pre>    Date-Time (GMT) Water Elevation [m NAVD88] exceedance probability return period     2012-10-30 01:00:00 3.357218 0.007233 138.263736   1960-09-12 18:00:00 2.295832 0.017830 56.086181   1992-12-11 14:00:00 2.108284 0.028427 35.178006   1953-11-07 12:00:00 2.101487 0.039024 25.625255   1950-11-25 14:00:00 2.012957 0.049621 20.152696     cunnane <pre><code>from pyextremes import get_extremes, get_return_periods\n\nextremes = get_extremes(\n    ts=data,\n    method=\"BM\",\n    block_size=\"365.2425D\",\n)\nreturn_periods = get_return_periods(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"BM\",\n    extremes_type=\"high\",\n    block_size=\"365.2425D\",\n    return_period_size=\"365.2425D\",\n    plotting_position=\"cunnane\",\n)\nreturn_periods.sort_values(\"return period\", ascending=False).head()\n</code></pre>    Date-Time (GMT) Water Elevation [m NAVD88] exceedance probability return period     2012-10-30 01:00:00 3.357218 0.006369 157.000000   1960-09-12 18:00:00 2.295832 0.016985 58.875000   1992-12-11 14:00:00 2.108284 0.027601 36.230769   1953-11-07 12:00:00 2.101487 0.038217 26.166667   1950-11-25 14:00:00 2.012957 0.048832 20.478261     gringorten <pre><code>from pyextremes import get_extremes, get_return_periods\n\nextremes = get_extremes(\n    ts=data,\n    method=\"BM\",\n    block_size=\"365.2425D\",\n)\nreturn_periods = get_return_periods(\n    ts=data,\n    extremes=extremes,\n    extremes_method=\"BM\",\n    extremes_type=\"high\",\n    block_size=\"365.2425D\",\n    return_period_size=\"365.2425D\",\n    plotting_position=\"gringorten\",\n)\nreturn_periods.sort_values(\"return period\", ascending=False).head()\n</code></pre>    Date-Time (GMT) Water Elevation [m NAVD88] exceedance probability return period     2012-10-30 01:00:00 3.357218 0.005950 168.071429   1960-09-12 18:00:00 2.295832 0.016575 60.333333   1992-12-11 14:00:00 2.108284 0.027199 36.765625   1953-11-07 12:00:00 2.101487 0.037824 26.438202   1950-11-25 14:00:00 2.012957 0.048449 20.640351      <p>The <code>get_return_periods</code> function uses the following parameters:</p> <ul> <li>ts - time series (<code>pandas.Series</code>) from which the extreme values are extracted</li> <li>extremes - time series of extreme values.</li> <li>extremes_method - extreme value extraction method, must be <code>\"BM\"</code> or   <code>\"POT\"</code>.</li> <li>extremes_type - extreme value type:   <code>\"high\"</code> for above threshold (default)   and <code>\"low\"</code> for below threshold.</li> <li>return_period_size - size of return period. Same as the <code>r</code> argument.   By default this is 1 year.</li> <li>plotting_position : plotting position name, case-insensitive.   Supported plotting positions: ecdf, hazen, weibull (default), tukey, blom, median,   cunnane, gringorten, beard.</li> </ul> <p>The following paramters are used only when <code>extremes_method=\"BM\"</code>:</p> <ul> <li>block_size - block size, by default <code>\"365.2425D\"</code>.   Internally is converted using the <code>pandas.to_timedelta</code> function.   If not provided, then it is calculated as median distance between extreme values.</li> </ul>  Note <p>You can get the <code>data</code> variable referenced above by running the following code:</p> <pre><code>data = pd.read_csv(\n    \"battery_wl.csv\",\n    index_col=0,\n    parse_dates=True,\n).squeeze()\ndata = (\n    data\n    .sort_index(ascending=True)\n    .astype(float)\n    .dropna()\n    .loc[pd.to_datetime(\"1925\"):]\n)\ndata = (\n  data - (data.index.array - pd.to_datetime(\"1992\"))\n) / pd.to_timedelta(\"365.2425D\") * 2.87e-3\n</code></pre> <p><code>\"battery_wl.csv\"</code> can be downloaded here.</p> <p>All figures shown in this tutorial section were generated using this jupyter notebook.</p>"},{"location":"user-guide/7-models/","title":"7 models","text":"<p>Means MLE and MCMC, not GEVD and GPD.</p>"},{"location":"user-guide/9-mcmc/","title":"9 mcmc","text":"<p>MAP instead of MLE.</p>"},{"location":"user-guide-advanced/1-distributions/","title":"1 distributions","text":"<p><code>Distribution</code> class and how it works.</p>"},{"location":"user-guide-advanced/2-extreme-value-transformation/","title":"2 extreme value transformation","text":"<p>Block minima and peaks-below-threshold.</p>"}]}